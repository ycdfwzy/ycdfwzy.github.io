---
title: 抢票小作业
---

这是我们抢票小组作业，目标是实现一个简单的支持高并发的微信抢票公众号，源码在[这里](https://github.com/hongfz16/WeChatTicket)。

小组成员：[hongfz16](https://github.com/hongfz16)，[ShadowIterator](https://github.com/ShadowIterator)，[sherlockcooper](https://github.com/sherlockcooper)，[我](https://github.com/ycdfwzy)

一些熟悉开发环境的部分不再赘述了，可以参考我们的项目文档和其他组员的技术文档。



## 处理订票的高并发性

这是一个在实际中比较普遍的问题：在抢票高峰期，服务器会同时收到$n$个订票请求（假设这些请求都是合法的），假设现在余票为$m$，但是$n>m$，一定会存在$n-m$个人订票失败。但是由于这些请求是同时发出的，可以假设服务器在不同线程处理这些请求，假设这$n$个线程同时访问数据库，它们的可以从数据库中发现还有余票可以处理本订票请求，于是他们都会告诉客户抢票成功，于是数据库里的余票就会变成$-(n-m)$张，这是不应发生的。

于是，为了在抢票高峰期（高并发）保证抢票过程逻辑的正确，需要给抢票这个过程加锁。Django提供了两种解决方式：悲观锁和乐观锁。

###悲观锁

悲观锁指对数据被外界修改持保守态度。于是在修改数据的过程中，数据会处于锁定状态，保证该线程对数据的独占性。Django提供了简单的悲观锁实现方法。

```Python
with django.db.transaction.atomic():
    data_to_update = dbname.objects.select_for_update().get(...)
    # some other work
```

`django.db.transaction.atomic`控制了数据库操作的原子性：如果`django.db.transaction.atomic`的代码成功执行，那么就可以将修改提交到数据库中，如果有异常抛出，那么这些数据库操作都会回滚。

`select_for_update`给数据表加上了共享锁，并在对应的行加上了独占锁，这样我们就可以放心修改对应的数据了。

### 乐观锁

乐观锁不是真正意义上的锁，他采取了更加宽松的数据访问修改机制。悲观锁虽然可以保证数据的绝对安全，但是带来了比较大的数据库性能开销，于是乐观锁应运而生了。乐观锁首先记录下待修改数据的原始值，如果一个数据需要修改的时候，其值没有变，那么可以认定在此期间没有其他程序访问修改它，直接修改即可；如果其值变了，那么放弃本次修改操作，重新访问并修改数据库，知道成功或者其他异常退出为止。

下面是乐观锁的一种实现方式：

```Python
while True:
    old_data = dbname.objects.get(id=id)
    new_data = get_new_data()
    res = dbname.objects.filter(id=id, data=old_data).update(data=new_data)
    if res == 0:
        # fail updating
        continue
    # succeed updating
    break
```

在实际使用中，一般情况下，悲观锁的操作时间普遍高于乐观锁，但是在极端情况下，乐观锁的没有效率上的保证，甚至可能会陷入死循环（小概率），但是悲观锁是可以有效率保证的。

本项目采用了悲观锁处理抢票并发问题。